<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vrmlproc &amp; togeom: vrml_proc::parser::model::utils::VrmlFieldExtractor Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">vrmlproc &amp; togeom
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacevrml__proc_1_1parser_1_1model_1_1utils_1_1_vrml_field_extractor.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">vrml_proc::parser::model::utils::VrmlFieldExtractor Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Represents low-level functions used for extracting and manipulating with <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html" title="Represents a VRML field.">VrmlField</a> and VrmlFieldValue types.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1edca47c85c2e19e6cf8e775c403f864" id="r_a1edca47c85c2e19e6cf8e775c403f864"><td class="memItemLeft" align="right" valign="top"><a id="a1edca47c85c2e19e6cf8e775c403f864" name="a1edca47c85c2e19e6cf8e775c403f864"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1edca47c85c2e19e6cf8e775c403f864">ExtractByNameError</a> { <b>FieldNotFound</b>
, <b>ValidationError</b>
 }</td></tr>
<tr class="memdesc:a1edca47c85c2e19e6cf8e775c403f864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents possible result of ExtractByName() function. <br /></td></tr>
<tr class="separator:a1edca47c85c2e19e6cf8e775c403f864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf83d75d592f1265c55bd55a434f20c" id="r_afcf83d75d592f1265c55bd55a434f20c"><td class="memItemLeft" align="right" valign="top"><a id="afcf83d75d592f1265c55bd55a434f20c" name="afcf83d75d592f1265c55bd55a434f20c"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcf83d75d592f1265c55bd55a434f20c">ExtractVrmlNodeError</a> { <b>FieldNotFound</b>
, <b>ValidationError</b>
, <b>UnknownUseNode</b>
 }</td></tr>
<tr class="memdesc:afcf83d75d592f1265c55bd55a434f20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents possible results of the ExtractVrmlNode() function. <br /></td></tr>
<tr class="separator:afcf83d75d592f1265c55bd55a434f20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e12d62f397681125a98fb18407e37d6" id="r_a1e12d62f397681125a98fb18407e37d6"><td class="memItemLeft" align="right" valign="top"><a id="a1e12d62f397681125a98fb18407e37d6" name="a1e12d62f397681125a98fb18407e37d6"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e12d62f397681125a98fb18407e37d6">ExtractVrmlNodeFromVariantError</a> { <b>ValidationError</b>
, <b>UnknownUseNode</b>
 }</td></tr>
<tr class="memdesc:a1e12d62f397681125a98fb18407e37d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents possible results of the ExtractVrmlNodeFromVariant() function. <br /></td></tr>
<tr class="separator:a1e12d62f397681125a98fb18407e37d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7336b0a845dcac9f3d5dcb5a069b9f54" id="r_a7336b0a845dcac9f3d5dcb5a069b9f54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7336b0a845dcac9f3d5dcb5a069b9f54">IsNamePresent</a> (const std::string &amp;name, const std::vector&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html">vrml_proc::parser::model::VrmlField</a> &gt; &amp;fields)</td></tr>
<tr class="memdesc:a7336b0a845dcac9f3d5dcb5a069b9f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the field name is present in list of fields.  <br /></td></tr>
<tr class="separator:a7336b0a845dcac9f3d5dcb5a069b9f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfe33815bcdae3a8349404249183100" id="r_a7bfe33815bcdae3a8349404249183100"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a7bfe33815bcdae3a8349404249183100"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::reference_wrapper&lt; const T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7bfe33815bcdae3a8349404249183100">ExtractExtended</a> (const vrml_proc::parser::model::VrmlFieldValue &amp;fieldValue, std::string &amp;invalidType)</td></tr>
<tr class="memdesc:a7bfe33815bcdae3a8349404249183100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts T value from the variant.  <br /></td></tr>
<tr class="separator:a7bfe33815bcdae3a8349404249183100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb670fd95b2c028968e5313db29c4426" id="r_adb670fd95b2c028968e5313db29c4426"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:adb670fd95b2c028968e5313db29c4426"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::reference_wrapper&lt; const T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adb670fd95b2c028968e5313db29c4426">Extract</a> (const vrml_proc::parser::model::VrmlFieldValue &amp;fieldValue)</td></tr>
<tr class="memdesc:adb670fd95b2c028968e5313db29c4426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts T value from the variant.  <br /></td></tr>
<tr class="separator:adb670fd95b2c028968e5313db29c4426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9680336f3d0ab7f3265979f8a8494dd9" id="r_a9680336f3d0ab7f3265979f8a8494dd9"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a9680336f3d0ab7f3265979f8a8494dd9"><td class="memTemplItemLeft" align="right" valign="top">cpp::result&lt; std::reference_wrapper&lt; const T &gt;, <a class="el" href="#a1edca47c85c2e19e6cf8e775c403f864">ExtractByNameError</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9680336f3d0ab7f3265979f8a8494dd9">ExtractByNameExtended</a> (const std::string &amp;name, const std::vector&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html">vrml_proc::parser::model::VrmlField</a> &gt; &amp;fields, std::string &amp;invalidType)</td></tr>
<tr class="memdesc:a9680336f3d0ab7f3265979f8a8494dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to extract a field of a specific type T by name.  <br /></td></tr>
<tr class="separator:a9680336f3d0ab7f3265979f8a8494dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163498850b1e7b748dab08eb0c2fe7a1" id="r_a163498850b1e7b748dab08eb0c2fe7a1"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a163498850b1e7b748dab08eb0c2fe7a1"><td class="memTemplItemLeft" align="right" valign="top">cpp::result&lt; std::reference_wrapper&lt; const T &gt;, <a class="el" href="#a1edca47c85c2e19e6cf8e775c403f864">ExtractByNameError</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a163498850b1e7b748dab08eb0c2fe7a1">ExtractByName</a> (const std::string &amp;name, const std::vector&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html">vrml_proc::parser::model::VrmlField</a> &gt; &amp;fields)</td></tr>
<tr class="memdesc:a163498850b1e7b748dab08eb0c2fe7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to extract a field of a specific type T by name.  <br /></td></tr>
<tr class="separator:a163498850b1e7b748dab08eb0c2fe7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad526472567a3c96e1559408ce618a232" id="r_ad526472567a3c96e1559408ce618a232"><td class="memItemLeft" align="right" valign="top">cpp::result&lt; std::reference_wrapper&lt; const <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt;, <a class="el" href="#afcf83d75d592f1265c55bd55a434f20c">ExtractVrmlNodeError</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad526472567a3c96e1559408ce618a232">ExtractVrmlNodeExtended</a> (const std::string &amp;name, const std::vector&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html">vrml_proc::parser::model::VrmlField</a> &gt; &amp;fields, const <a class="el" href="classvrml__proc_1_1parser_1_1service_1_1_vrml_node_manager.html">vrml_proc::parser::service::VrmlNodeManager</a> &amp;manager, std::string &amp;invalidType, std::string &amp;useId)</td></tr>
<tr class="memdesc:ad526472567a3c96e1559408ce618a232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a VRML node or resolves a <code>USE</code> reference from a field list.  <br /></td></tr>
<tr class="separator:ad526472567a3c96e1559408ce618a232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bc7af856afbdf82bf02865d2e61b37" id="r_ac3bc7af856afbdf82bf02865d2e61b37"><td class="memItemLeft" align="right" valign="top">cpp::result&lt; std::reference_wrapper&lt; const <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt;, <a class="el" href="#afcf83d75d592f1265c55bd55a434f20c">ExtractVrmlNodeError</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3bc7af856afbdf82bf02865d2e61b37">ExtractVrmlNode</a> (const std::string &amp;name, const std::vector&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html">vrml_proc::parser::model::VrmlField</a> &gt; &amp;fields, const <a class="el" href="classvrml__proc_1_1parser_1_1service_1_1_vrml_node_manager.html">vrml_proc::parser::service::VrmlNodeManager</a> &amp;manager)</td></tr>
<tr class="memdesc:ac3bc7af856afbdf82bf02865d2e61b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a VRML node or resolves a <code>USE</code> reference from a field list.  <br /></td></tr>
<tr class="separator:ac3bc7af856afbdf82bf02865d2e61b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81c4726adfebfe142d4e4e971d0b909" id="r_af81c4726adfebfe142d4e4e971d0b909"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:af81c4726adfebfe142d4e4e971d0b909"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::reference_wrapper&lt; const T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af81c4726adfebfe142d4e4e971d0b909">ExtractVrmlNodeFromVariantWithoutResolvingExtended</a> (const boost::variant&lt; boost::recursive_wrapper&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt;, boost::recursive_wrapper&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html">vrml_proc::parser::model::UseNode</a> &gt; &gt; &amp;variant, std::string &amp;invalidType)</td></tr>
<tr class="memdesc:af81c4726adfebfe142d4e4e971d0b909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to extract a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> or <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html" title="Represents a VRML 2.0 USE node.">UseNode</a></code> from a variant without resolving <code>USE</code> references.  <br /></td></tr>
<tr class="separator:af81c4726adfebfe142d4e4e971d0b909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36077555eb784303fda76168f98ec7f6" id="r_a36077555eb784303fda76168f98ec7f6"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a36077555eb784303fda76168f98ec7f6"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::reference_wrapper&lt; const T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a36077555eb784303fda76168f98ec7f6">ExtractVrmlNodeFromVariantWithoutResolving</a> (const boost::variant&lt; boost::recursive_wrapper&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt;, boost::recursive_wrapper&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html">vrml_proc::parser::model::UseNode</a> &gt; &gt; &amp;variant)</td></tr>
<tr class="memdesc:a36077555eb784303fda76168f98ec7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to extract a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> or <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html" title="Represents a VRML 2.0 USE node.">UseNode</a></code> from a variant without resolving <code>USE</code> references.  <br /></td></tr>
<tr class="separator:a36077555eb784303fda76168f98ec7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad049ebcdedbe6a393491a6a153320a2f" id="r_ad049ebcdedbe6a393491a6a153320a2f"><td class="memItemLeft" align="right" valign="top">cpp::result&lt; std::reference_wrapper&lt; const <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt;, <a class="el" href="#a1e12d62f397681125a98fb18407e37d6">ExtractVrmlNodeFromVariantError</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad049ebcdedbe6a393491a6a153320a2f">ExtractVrmlNodeFromVariantExtended</a> (const boost::variant&lt; boost::recursive_wrapper&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt;, boost::recursive_wrapper&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html">vrml_proc::parser::model::UseNode</a> &gt; &gt; &amp;variant, const <a class="el" href="classvrml__proc_1_1parser_1_1service_1_1_vrml_node_manager.html">vrml_proc::parser::service::VrmlNodeManager</a> &amp;manager, std::string &amp;invalidType, std::string &amp;useId)</td></tr>
<tr class="memdesc:ad049ebcdedbe6a393491a6a153320a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to extract a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> from a variant, resolving <code>USE</code> references.  <br /></td></tr>
<tr class="separator:ad049ebcdedbe6a393491a6a153320a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ce7bb09d683cfdda10eeaffb7059b0" id="r_ad1ce7bb09d683cfdda10eeaffb7059b0"><td class="memItemLeft" align="right" valign="top">cpp::result&lt; std::reference_wrapper&lt; const <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt;, <a class="el" href="#a1e12d62f397681125a98fb18407e37d6">ExtractVrmlNodeFromVariantError</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1ce7bb09d683cfdda10eeaffb7059b0">ExtractVrmlNodeFromVariant</a> (const boost::variant&lt; boost::recursive_wrapper&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt;, boost::recursive_wrapper&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html">vrml_proc::parser::model::UseNode</a> &gt; &gt; &amp;variant, const <a class="el" href="classvrml__proc_1_1parser_1_1service_1_1_vrml_node_manager.html">vrml_proc::parser::service::VrmlNodeManager</a> &amp;manager)</td></tr>
<tr class="memdesc:ad1ce7bb09d683cfdda10eeaffb7059b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to extract a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> from a variant, resolving <code>USE</code> references.  <br /></td></tr>
<tr class="separator:ad1ce7bb09d683cfdda10eeaffb7059b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents low-level functions used for extracting and manipulating with <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html" title="Represents a VRML field.">VrmlField</a> and VrmlFieldValue types. </p>
<p>These types are defined simply as variants of many different possible values mirroring the VRML 2.0 standart. These structs are left barebone, and thus addtional utils functions are needed to manipulation with them. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="adb670fd95b2c028968e5313db29c4426" name="adb670fd95b2c028968e5313db29c4426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb670fd95b2c028968e5313db29c4426">&#9670;&#160;</a></span>Extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::reference_wrapper&lt; const T &gt; &gt; vrml_proc::parser::model::utils::VrmlFieldExtractor::Extract </td>
          <td>(</td>
          <td class="paramtype">const vrml_proc::parser::model::VrmlFieldValue &amp;</td>          <td class="paramname"><span class="paramname"><em>fieldValue</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts T value from the variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to extract </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldValue</td><td>field value (variant) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>optional storing the reference to the const T value from variant if T can be extracted, otherwise nullopt </dd></dl>

</div>
</div>
<a id="a163498850b1e7b748dab08eb0c2fe7a1" name="a163498850b1e7b748dab08eb0c2fe7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163498850b1e7b748dab08eb0c2fe7a1">&#9670;&#160;</a></span>ExtractByName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cpp::result&lt; std::reference_wrapper&lt; const T &gt;, <a class="el" href="#a1edca47c85c2e19e6cf8e775c403f864">ExtractByNameError</a> &gt; vrml_proc::parser::model::utils::VrmlFieldExtractor::ExtractByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html">vrml_proc::parser::model::VrmlField</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fields</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to extract a field of a specific type T by name. </p>
<p>This function searches for a field with a given name in the provided list of VRML fields. If the field is found and its type matches the expected type <code>T</code>, it returns a reference to the value. Otherwise, it returns an appropriate <code><a class="el" href="#a1edca47c85c2e19e6cf8e775c403f864" title="Represents possible result of ExtractByName() function.">ExtractByNameError</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>expected type of the field value to extract </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the field to look for </td></tr>
    <tr><td class="paramname">fields</td><td>list of available VRML fields </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code>cpp::result</code> containing a reference to the extracted value if successful, or an <code><a class="el" href="#a1edca47c85c2e19e6cf8e775c403f864" title="Represents possible result of ExtractByName() function.">ExtractByNameError</a></code> on failure </dd></dl>

</div>
</div>
<a id="a9680336f3d0ab7f3265979f8a8494dd9" name="a9680336f3d0ab7f3265979f8a8494dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9680336f3d0ab7f3265979f8a8494dd9">&#9670;&#160;</a></span>ExtractByNameExtended()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cpp::result&lt; std::reference_wrapper&lt; const T &gt;, <a class="el" href="#a1edca47c85c2e19e6cf8e775c403f864">ExtractByNameError</a> &gt; vrml_proc::parser::model::utils::VrmlFieldExtractor::ExtractByNameExtended </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html">vrml_proc::parser::model::VrmlField</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fields</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>invalidType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to extract a field of a specific type T by name. </p>
<p>This function searches for a field with a given name in the provided list of VRML fields. If the field is found and its type matches the expected type <code>T</code>, it returns a reference to the value. Otherwise, it returns an appropriate <code><a class="el" href="#a1edca47c85c2e19e6cf8e775c403f864" title="Represents possible result of ExtractByName() function.">ExtractByNameError</a></code>.</p>
<p>If a validation error occurs (i.e., the field is found but its type is incorrect), the <code>invalidType</code> string will be updated with a invalid type of the mismatch.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>expected type of the field value to extract </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the field to look for </td></tr>
    <tr><td class="paramname">fields</td><td>list of available VRML fields </td></tr>
    <tr><td class="paramname">invalidType</td><td>string to receive the name of the mismatched type if validation fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code>cpp::result</code> containing a reference to the extracted value if successful, or an <code><a class="el" href="#a1edca47c85c2e19e6cf8e775c403f864" title="Represents possible result of ExtractByName() function.">ExtractByNameError</a></code> on failure </dd></dl>

</div>
</div>
<a id="a7bfe33815bcdae3a8349404249183100" name="a7bfe33815bcdae3a8349404249183100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfe33815bcdae3a8349404249183100">&#9670;&#160;</a></span>ExtractExtended()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::reference_wrapper&lt; const T &gt; &gt; vrml_proc::parser::model::utils::VrmlFieldExtractor::ExtractExtended </td>
          <td>(</td>
          <td class="paramtype">const vrml_proc::parser::model::VrmlFieldValue &amp;</td>          <td class="paramname"><span class="paramname"><em>fieldValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>invalidType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts T value from the variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to extract </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldValue</td><td>field value (variant) </td></tr>
    <tr><td class="paramname">invalidType</td><td>out parameter, which is filled with invalid type name, if T cannot be extracted from <code>fieldValue</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>optional storing the reference to the const T value from variant if T can be extracted, otherwise nullopt </dd></dl>

</div>
</div>
<a id="ac3bc7af856afbdf82bf02865d2e61b37" name="ac3bc7af856afbdf82bf02865d2e61b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bc7af856afbdf82bf02865d2e61b37">&#9670;&#160;</a></span>ExtractVrmlNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cpp::result&lt; std::reference_wrapper&lt; const <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt;, <a class="el" href="#afcf83d75d592f1265c55bd55a434f20c">ExtractVrmlNodeError</a> &gt; vrml_proc::parser::model::utils::VrmlFieldExtractor::ExtractVrmlNode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html">vrml_proc::parser::model::VrmlField</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fields</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvrml__proc_1_1parser_1_1service_1_1_vrml_node_manager.html">vrml_proc::parser::service::VrmlNodeManager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>manager</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a VRML node or resolves a <code>USE</code> reference from a field list. </p>
<p>This function attempts to extract a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> with the given name from the provided list of fields. If a matching node of the correct type is not found, it checks whether the name refers to a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html" title="Represents a VRML 2.0 USE node.">UseNode</a></code> and attempts to resolve the reference via the <code>VrmlNodeManager</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the node field to search for </td></tr>
    <tr><td class="paramname">fields</td><td>list of available VRML fields </td></tr>
    <tr><td class="paramname">manager</td><td>reference to the <code>VrmlNodeManager</code> used to resolve <code>USE</code> references </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code>cpp::result</code> containing a reference to the resolved <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code>, or an <code><a class="el" href="#afcf83d75d592f1265c55bd55a434f20c" title="Represents possible results of the ExtractVrmlNode() function.">ExtractVrmlNodeError</a></code> on failure </dd></dl>

</div>
</div>
<a id="ad526472567a3c96e1559408ce618a232" name="ad526472567a3c96e1559408ce618a232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad526472567a3c96e1559408ce618a232">&#9670;&#160;</a></span>ExtractVrmlNodeExtended()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cpp::result&lt; std::reference_wrapper&lt; const <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt;, <a class="el" href="#afcf83d75d592f1265c55bd55a434f20c">ExtractVrmlNodeError</a> &gt; vrml_proc::parser::model::utils::VrmlFieldExtractor::ExtractVrmlNodeExtended </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html">vrml_proc::parser::model::VrmlField</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fields</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvrml__proc_1_1parser_1_1service_1_1_vrml_node_manager.html">vrml_proc::parser::service::VrmlNodeManager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>manager</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>invalidType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>useId</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a VRML node or resolves a <code>USE</code> reference from a field list. </p>
<p>This function attempts to extract a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> with the given name from the provided list of fields. If a matching node of the correct type is not found, it checks whether the name refers to a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html" title="Represents a VRML 2.0 USE node.">UseNode</a></code> and attempts to resolve the reference via the <code>VrmlNodeManager</code>.</p>
<p>On failure due to a type mismatch, the <code>invalidType</code> string is populated. If the node is a <code>USE</code> reference that could not be resolved, the <code>useId</code> string is populated with the unresolved identifier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the node field to search for </td></tr>
    <tr><td class="paramname">fields</td><td>list of available VRML fields </td></tr>
    <tr><td class="paramname">manager</td><td>reference to the <code>VrmlNodeManager</code> used to resolve <code>USE</code> references </td></tr>
    <tr><td class="paramname">invalidType</td><td>will be populated with type error information if type validation fail </td></tr>
    <tr><td class="paramname">useId</td><td>will be populated with the unresolved identifier if a <code>USE</code> reference fails to resolve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code>cpp::result</code> containing a reference to the resolved <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code>, or an <code><a class="el" href="#afcf83d75d592f1265c55bd55a434f20c" title="Represents possible results of the ExtractVrmlNode() function.">ExtractVrmlNodeError</a></code> on failure </dd></dl>

</div>
</div>
<a id="ad1ce7bb09d683cfdda10eeaffb7059b0" name="ad1ce7bb09d683cfdda10eeaffb7059b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ce7bb09d683cfdda10eeaffb7059b0">&#9670;&#160;</a></span>ExtractVrmlNodeFromVariant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cpp::result&lt; std::reference_wrapper&lt; const <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt;, <a class="el" href="#a1e12d62f397681125a98fb18407e37d6">ExtractVrmlNodeFromVariantError</a> &gt; vrml_proc::parser::model::utils::VrmlFieldExtractor::ExtractVrmlNodeFromVariant </td>
          <td>(</td>
          <td class="paramtype">const boost::variant&lt; boost::recursive_wrapper&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt;, boost::recursive_wrapper&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html">vrml_proc::parser::model::UseNode</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>variant</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvrml__proc_1_1parser_1_1service_1_1_vrml_node_manager.html">vrml_proc::parser::service::VrmlNodeManager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>manager</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to extract a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> from a variant, resolving <code>USE</code> references. </p>
<p>This function handles a variant containing either a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> or a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html" title="Represents a VRML 2.0 USE node.">UseNode</a></code>. It first tries to extract a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> directly. If the contained type is a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html" title="Represents a VRML 2.0 USE node.">UseNode</a></code>, the function attempts to resolve it using the provided <code>VrmlNodeManager</code>. If the referenced node cannot be resolved, the function returns an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variant</td><td>variant that may contain either a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> or a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html" title="Represents a VRML 2.0 USE node.">UseNode</a></code>. </td></tr>
    <tr><td class="paramname">manager</td><td>manager used to resolve nodes referenced by <code>USE</code> statements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code>cpp::result</code> holding either a reference to the resolved <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> or an error code indicating failure </dd></dl>

</div>
</div>
<a id="ad049ebcdedbe6a393491a6a153320a2f" name="ad049ebcdedbe6a393491a6a153320a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad049ebcdedbe6a393491a6a153320a2f">&#9670;&#160;</a></span>ExtractVrmlNodeFromVariantExtended()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cpp::result&lt; std::reference_wrapper&lt; const <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt;, <a class="el" href="#a1e12d62f397681125a98fb18407e37d6">ExtractVrmlNodeFromVariantError</a> &gt; vrml_proc::parser::model::utils::VrmlFieldExtractor::ExtractVrmlNodeFromVariantExtended </td>
          <td>(</td>
          <td class="paramtype">const boost::variant&lt; boost::recursive_wrapper&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt;, boost::recursive_wrapper&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html">vrml_proc::parser::model::UseNode</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>variant</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvrml__proc_1_1parser_1_1service_1_1_vrml_node_manager.html">vrml_proc::parser::service::VrmlNodeManager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>manager</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>invalidType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>useId</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to extract a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> from a variant, resolving <code>USE</code> references. </p>
<p>This function handles a variant containing either a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> or a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html" title="Represents a VRML 2.0 USE node.">UseNode</a></code>. It first tries to extract a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> directly. If the contained type is a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html" title="Represents a VRML 2.0 USE node.">UseNode</a></code>, the function attempts to resolve it using the provided <code>VrmlNodeManager</code>. If the referenced node cannot be resolved, the function returns an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variant</td><td>variant that may contain either a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> or a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html" title="Represents a VRML 2.0 USE node.">UseNode</a></code>. </td></tr>
    <tr><td class="paramname">manager</td><td>manager used to resolve nodes referenced by <code>USE</code> statements. </td></tr>
    <tr><td class="paramname">invalidType</td><td>will be populated with a string describing the type mismatch or validation issue </td></tr>
    <tr><td class="paramname">useId</td><td>will be populated with the identifier from the <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html" title="Represents a VRML 2.0 USE node.">UseNode</a></code> if the resolution fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code>cpp::result</code> holding either a reference to the resolved <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> or an error code indicating failure </dd></dl>

</div>
</div>
<a id="a36077555eb784303fda76168f98ec7f6" name="a36077555eb784303fda76168f98ec7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36077555eb784303fda76168f98ec7f6">&#9670;&#160;</a></span>ExtractVrmlNodeFromVariantWithoutResolving()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::reference_wrapper&lt; const T &gt; &gt; vrml_proc::parser::model::utils::VrmlFieldExtractor::ExtractVrmlNodeFromVariantWithoutResolving </td>
          <td>(</td>
          <td class="paramtype">const boost::variant&lt; boost::recursive_wrapper&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt;, boost::recursive_wrapper&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html">vrml_proc::parser::model::UseNode</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>variant</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to extract a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> or <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html" title="Represents a VRML 2.0 USE node.">UseNode</a></code> from a variant without resolving <code>USE</code> references. </p>
<p>This function extracts a variant that may contain either a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> or <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html" title="Represents a VRML 2.0 USE node.">UseNode</a></code>. This function does not attempt to resolve <code>USE</code> references via a node manager.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>expected type of VRML node to extract (<code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> or <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html" title="Represents a VRML 2.0 USE node.">UseNode</a></code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variant</td><td>variant potentially containing a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> or <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html" title="Represents a VRML 2.0 USE node.">UseNode</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <code>std::optional</code> containing a reference to the extracted object if successful; otherwise, nullopt </dd></dl>

</div>
</div>
<a id="af81c4726adfebfe142d4e4e971d0b909" name="af81c4726adfebfe142d4e4e971d0b909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81c4726adfebfe142d4e4e971d0b909">&#9670;&#160;</a></span>ExtractVrmlNodeFromVariantWithoutResolvingExtended()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::reference_wrapper&lt; const T &gt; &gt; vrml_proc::parser::model::utils::VrmlFieldExtractor::ExtractVrmlNodeFromVariantWithoutResolvingExtended </td>
          <td>(</td>
          <td class="paramtype">const boost::variant&lt; boost::recursive_wrapper&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt;, boost::recursive_wrapper&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html">vrml_proc::parser::model::UseNode</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>variant</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>invalidType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to extract a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> or <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html" title="Represents a VRML 2.0 USE node.">UseNode</a></code> from a variant without resolving <code>USE</code> references. </p>
<p>This function extracts a variant that may contain either a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> or <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html" title="Represents a VRML 2.0 USE node.">UseNode</a></code>. This function does not attempt to resolve <code>USE</code> references via a node manager.</p>
<p>If the extraction fails due to a type mismatch, <code>invalidType</code> is populated with the error description.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>expected type of VRML node to extract (<code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> or <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html" title="Represents a VRML 2.0 USE node.">UseNode</a></code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variant</td><td>variant potentially containing a <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html" title="Represents a VRML node.">VrmlNode</a></code> or <code><a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_use_node.html" title="Represents a VRML 2.0 USE node.">UseNode</a></code> </td></tr>
    <tr><td class="paramname">invalidType</td><td>qill be populated with error details if extraction fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <code>std::optional</code> containing a reference to the extracted object if successful; otherwise, nullopt </dd></dl>

</div>
</div>
<a id="a7336b0a845dcac9f3d5dcb5a069b9f54" name="a7336b0a845dcac9f3d5dcb5a069b9f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7336b0a845dcac9f3d5dcb5a069b9f54">&#9670;&#160;</a></span>IsNamePresent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vrml_proc::parser::model::utils::VrmlFieldExtractor::IsNamePresent </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html">vrml_proc::parser::model::VrmlField</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fields</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the field name is present in list of fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name to find </td></tr>
    <tr><td class="paramname">fields</td><td>list of fields </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the name was found, otherwise false </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>vrml_proc</b></li><li class="navelem"><b>parser</b></li><li class="navelem"><b>model</b></li><li class="navelem"><b>utils</b></li><li class="navelem"><a class="el" href="namespacevrml__proc_1_1parser_1_1model_1_1utils_1_1_vrml_field_extractor.html">VrmlFieldExtractor</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
