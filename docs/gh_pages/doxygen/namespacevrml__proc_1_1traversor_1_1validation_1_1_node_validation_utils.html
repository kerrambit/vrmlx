<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vrmlproc &amp; togeom: vrml_proc::traversor::validation::NodeValidationUtils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">vrmlproc &amp; togeom
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacevrml__proc_1_1traversor_1_1validation_1_1_node_validation_utils.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">vrml_proc::traversor::validation::NodeValidationUtils Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Groups static helper functions to work with VRML node more easily. Functions work as a bridge between raw outputs of VrmlFieldExtractor and nicely formatted output of NodeValidationError entities. Validate method encapsulates the underlying methods and logic.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a230ac1e22e65420b56261b8ac4aeb84d" id="r_a230ac1e22e65420b56261b8ac4aeb84d"><td class="memItemLeft" align="right" valign="top">cpp::result&lt; void, std::shared_ptr&lt; <a class="el" href="classvrml__proc_1_1traversor_1_1validation_1_1error_1_1_node_validation_error.html">error::NodeValidationError</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a230ac1e22e65420b56261b8ac4aeb84d">CheckForOnlyUniqueAllowedFieldNames</a> (const std::unordered_set&lt; std::string &gt; &amp;validFieldNames, const std::vector&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html">vrml_proc::parser::model::VrmlField</a> &gt; &amp;fields, const std::string &amp;nodeName)</td></tr>
<tr class="memdesc:a230ac1e22e65420b56261b8ac4aeb84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static helper method which checks that all field names are from the given list of allowed names. Method also verifies that each field name is used at most once and that no unknown field name is used either.  <br /></td></tr>
<tr class="separator:a230ac1e22e65420b56261b8ac4aeb84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6394de612b01e5e9d739e29ab3e5f9b9" id="r_a6394de612b01e5e9d739e29ab3e5f9b9"><td class="memItemLeft" align="right" valign="top">cpp::result&lt; void, std::shared_ptr&lt; <a class="el" href="classvrml__proc_1_1traversor_1_1validation_1_1error_1_1_node_validation_error.html">error::NodeValidationError</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6394de612b01e5e9d739e29ab3e5f9b9">CheckForOnlyAllowedVrmlNodeHeaders</a> (const std::unordered_set&lt; std::string &gt; &amp;validHeaders, const <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &amp;node, const std::string &amp;field)</td></tr>
<tr class="memdesc:a6394de612b01e5e9d739e29ab3e5f9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static helper method which checks if node has valid header. Basically this method checks the "kind" of a VRML node.  <br /></td></tr>
<tr class="separator:a6394de612b01e5e9d739e29ab3e5f9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4787cf46769be3d076db4ba3ff7354f4" id="r_a4787cf46769be3d076db4ba3ff7354f4"><td class="memItemLeft" align="right" valign="top">cpp::result&lt; std::optional&lt; std::reference_wrapper&lt; const <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt; &gt;, std::shared_ptr&lt; <a class="el" href="classvrml__proc_1_1traversor_1_1validation_1_1error_1_1_node_validation_error.html">error::NodeValidationError</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4787cf46769be3d076db4ba3ff7354f4">ExtractVrmlNodeWithValidation</a> (const std::string &amp;fieldName, const std::vector&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html">vrml_proc::parser::model::VrmlField</a> &gt; &amp;fields, const <a class="el" href="classvrml__proc_1_1parser_1_1service_1_1_vrml_node_manager.html">vrml_proc::parser::service::VrmlNodeManager</a> &amp;manager)</td></tr>
<tr class="memdesc:a4787cf46769be3d076db4ba3ff7354f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static helper method which validates field entry of type VrmlNode (or UseNode which is resolved to VrmlNode).  <br /></td></tr>
<tr class="separator:a4787cf46769be3d076db4ba3ff7354f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada398366380fc643dbdf4164d2c9d76c" id="r_ada398366380fc643dbdf4164d2c9d76c"><td class="memTemplParams" colspan="2">template&lt;typename ExpectedType&gt; </td></tr>
<tr class="memitem:ada398366380fc643dbdf4164d2c9d76c"><td class="memTemplItemLeft" align="right" valign="top">cpp::result&lt; std::optional&lt; std::reference_wrapper&lt; const ExpectedType &gt; &gt;, std::shared_ptr&lt; <a class="el" href="classvrml__proc_1_1traversor_1_1validation_1_1error_1_1_node_validation_error.html">error::NodeValidationError</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ada398366380fc643dbdf4164d2c9d76c">ExtractFieldByNameWithValidation</a> (const std::string &amp;fieldName, const std::vector&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html">vrml_proc::parser::model::VrmlField</a> &gt; &amp;fields)</td></tr>
<tr class="memdesc:ada398366380fc643dbdf4164d2c9d76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static helper method which validates field entry. Field type is templated.  <br /></td></tr>
<tr class="separator:ada398366380fc643dbdf4164d2c9d76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ab393e99d5c65acd9a3aa779f38ae2" id="r_ad0ab393e99d5c65acd9a3aa779f38ae2"><td class="memItemLeft" align="right" valign="top">cpp::result&lt; std::optional&lt; std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt; &gt; &gt;, std::shared_ptr&lt; <a class="el" href="classvrml__proc_1_1traversor_1_1validation_1_1error_1_1_node_validation_error.html">error::NodeValidationError</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0ab393e99d5c65acd9a3aa779f38ae2">ExtractVrmlNodeArrayWithValidation</a> (const std::string &amp;fieldName, const std::vector&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html">vrml_proc::parser::model::VrmlField</a> &gt; &amp;fields, const <a class="el" href="classvrml__proc_1_1parser_1_1service_1_1_vrml_node_manager.html">vrml_proc::parser::service::VrmlNodeManager</a> &amp;manager, bool enableSingleArrayNode=false)</td></tr>
<tr class="memdesc:ad0ab393e99d5c65acd9a3aa779f38ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static helper method which validates field entry of expected type VRML node array and resolves found USE nodes into VRML nodes.  <br /></td></tr>
<tr class="separator:ad0ab393e99d5c65acd9a3aa779f38ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Groups static helper functions to work with VRML node more easily. Functions work as a bridge between raw outputs of VrmlFieldExtractor and nicely formatted output of NodeValidationError entities. Validate method encapsulates the underlying methods and logic. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a6394de612b01e5e9d739e29ab3e5f9b9" name="a6394de612b01e5e9d739e29ab3e5f9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6394de612b01e5e9d739e29ab3e5f9b9">&#9670;&#160;</a></span>CheckForOnlyAllowedVrmlNodeHeaders()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cpp::result&lt; void, std::shared_ptr&lt; <a class="el" href="classvrml__proc_1_1traversor_1_1validation_1_1error_1_1_node_validation_error.html">error::NodeValidationError</a> &gt; &gt; vrml_proc::traversor::validation::NodeValidationUtils::CheckForOnlyAllowedVrmlNodeHeaders </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_set&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>validHeaders</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>field</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static helper method which checks if node has valid header. Basically this method checks the "kind" of a VRML node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">validHeaders</td><td>set of allowed header names, if set is empty, no check will be run </td></tr>
    <tr><td class="paramname">node</td><td>node to verify </td></tr>
    <tr><td class="paramname">field</td><td>field which node belongs to in the node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result type where error stores the NodeValidationError subtype </dd></dl>

</div>
</div>
<a id="a230ac1e22e65420b56261b8ac4aeb84d" name="a230ac1e22e65420b56261b8ac4aeb84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230ac1e22e65420b56261b8ac4aeb84d">&#9670;&#160;</a></span>CheckForOnlyUniqueAllowedFieldNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cpp::result&lt; void, std::shared_ptr&lt; <a class="el" href="classvrml__proc_1_1traversor_1_1validation_1_1error_1_1_node_validation_error.html">error::NodeValidationError</a> &gt; &gt; vrml_proc::traversor::validation::NodeValidationUtils::CheckForOnlyUniqueAllowedFieldNames </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_set&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>validFieldNames</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html">vrml_proc::parser::model::VrmlField</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fields</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>nodeName</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static helper method which checks that all field names are from the given list of allowed names. Method also verifies that each field name is used at most once and that no unknown field name is used either. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">validFieldNames</td><td>set of all allowed field names </td></tr>
    <tr><td class="paramname">fields</td><td>list of fields to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result type where error stores the NodeValidationError subtype </dd></dl>

</div>
</div>
<a id="ada398366380fc643dbdf4164d2c9d76c" name="ada398366380fc643dbdf4164d2c9d76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada398366380fc643dbdf4164d2c9d76c">&#9670;&#160;</a></span>ExtractFieldByNameWithValidation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpectedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cpp::result&lt; std::optional&lt; std::reference_wrapper&lt; const ExpectedType &gt; &gt;, std::shared_ptr&lt; <a class="el" href="classvrml__proc_1_1traversor_1_1validation_1_1error_1_1_node_validation_error.html">error::NodeValidationError</a> &gt; &gt; vrml_proc::traversor::validation::NodeValidationUtils::ExtractFieldByNameWithValidation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fieldName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html">vrml_proc::parser::model::VrmlField</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fields</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static helper method which validates field entry. Field type is templated. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>
<p>param name name of the field </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fields</td><td>list of all node's fields</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NodeValidationError if failure occurs (invalid field type); otherwise it returns empty optional (field is missing) or optional containing const reference to T </dd></dl>

</div>
</div>
<a id="ad0ab393e99d5c65acd9a3aa779f38ae2" name="ad0ab393e99d5c65acd9a3aa779f38ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ab393e99d5c65acd9a3aa779f38ae2">&#9670;&#160;</a></span>ExtractVrmlNodeArrayWithValidation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cpp::result&lt; std::optional&lt; std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt; &gt; &gt;, std::shared_ptr&lt; <a class="el" href="classvrml__proc_1_1traversor_1_1validation_1_1error_1_1_node_validation_error.html">error::NodeValidationError</a> &gt; &gt; vrml_proc::traversor::validation::NodeValidationUtils::ExtractVrmlNodeArrayWithValidation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fieldName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html">vrml_proc::parser::model::VrmlField</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fields</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvrml__proc_1_1parser_1_1service_1_1_vrml_node_manager.html">vrml_proc::parser::service::VrmlNodeManager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>manager</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enableSingleArrayNode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static helper method which validates field entry of expected type VRML node array and resolves found USE nodes into VRML nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field </td></tr>
    <tr><td class="paramname">fields</td><td>vector of node's fields </td></tr>
    <tr><td class="paramname">manager</td><td>VRML manager </td></tr>
    <tr><td class="paramname">enableSingleArrayNode</td><td>flag which enables to extract also signular VRML node instead of VRML node array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NodeValidationError if the field has wrong type (or if any USE node cannot found its corresponding DEF node); otherwise it returns empty optional (field is missing) or optional containing vector of const references to VRML nodes </dd></dl>

</div>
</div>
<a id="a4787cf46769be3d076db4ba3ff7354f4" name="a4787cf46769be3d076db4ba3ff7354f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4787cf46769be3d076db4ba3ff7354f4">&#9670;&#160;</a></span>ExtractVrmlNodeWithValidation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cpp::result&lt; std::optional&lt; std::reference_wrapper&lt; const <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_node.html">vrml_proc::parser::model::VrmlNode</a> &gt; &gt;, std::shared_ptr&lt; <a class="el" href="classvrml__proc_1_1traversor_1_1validation_1_1error_1_1_node_validation_error.html">error::NodeValidationError</a> &gt; &gt; vrml_proc::traversor::validation::NodeValidationUtils::ExtractVrmlNodeWithValidation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fieldName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structvrml__proc_1_1parser_1_1model_1_1_vrml_field.html">vrml_proc::parser::model::VrmlField</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fields</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvrml__proc_1_1parser_1_1service_1_1_vrml_node_manager.html">vrml_proc::parser::service::VrmlNodeManager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>manager</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static helper method which validates field entry of type VrmlNode (or UseNode which is resolved to VrmlNode). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the expected field </td></tr>
    <tr><td class="paramname">fields</td><td>list of all node's fields </td></tr>
    <tr><td class="paramname">manager</td><td>manager where associations between UseNodes and VrmlNodes will be searched for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NodeValidationError if failure occurs (invalid field type, missing VrmlNode for UseNode id); otherwise it returns empty optional (field is missing) or const reference to VRML node </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>vrml_proc</b></li><li class="navelem"><b>traversor</b></li><li class="navelem"><b>validation</b></li><li class="navelem"><a class="el" href="namespacevrml__proc_1_1traversor_1_1validation_1_1_node_validation_utils.html">NodeValidationUtils</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
